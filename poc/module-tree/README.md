# POC: Module Tree Pattern & Nitro Integration

## Overview

This POC demonstrates Hexane's complete architecture:
- **User-facing API**: Clean module-based application structure
- **Nitro Integration**: Framework-managed, hidden from users
- **Deployment Flexibility**: Works with all Nitro targets

## Goals

‚úÖ Prove module tree composition works with TypeScript
‚úÖ Validate seamless Nitro integration (hidden from users)
‚úÖ Provide clean, intuitive developer experience
‚úÖ Show modules can declare dependencies on other modules
‚úÖ Demonstrate zero-config deployment to multiple targets

## User Experience

### POC (Current - Educational)
This POC shows all files including `routes/[...].ts` and `nitro.config.ts` for learning purposes.

### Production (v1.0 - See FUTURE_ARCHITECTURE.md)
In production, users will have a completely clean project:

```typescript
// app/main.ts - User's ONLY framework interaction
export { AppModule } from './app.module'
```

The framework will handle all Nitro integration via CLI:
```bash
npm run dev     # Actually runs: hexane dev
npm run build   # Actually runs: hexane build
```

**Users will never see:**
- ‚ùå `routes/[...].ts` - Managed by `@hexane/core`
- ‚ùå `nitro.config.ts` - Generated by CLI
- ‚ùå Framework plumbing - Hidden in node_modules

**See [FUTURE_ARCHITECTURE.md](./FUTURE_ARCHITECTURE.md) for complete production design.**

## Design

### Module Tree Pattern

Applications are composed of modules that import other modules, forming a dependency tree:

```typescript
// app.module.ts (root)
export const AppModule = defineModule({
  imports: [UsersModule, ProductsModule],
  providers: [AppService],
})

// modules/users/users.module.ts
export const UsersModule = defineModule({
  name: 'users',
  routes: [usersRoutes],
  providers: [UserService],
  exports: [UserService], // Available to importing modules
})
```

### Entry Point

Simple, explicit entry point:

```typescript
// main.ts
import { createApp } from './core'
import { AppModule } from './app.module'

const app = await createApp(AppModule)
export default app
```

### Build Integration

- Uses standard Nitro build (no custom CLI)
- Entry point: `main.ts`
- Vite dev server for HMR
- Standard ESM imports

## Files

### User Code (What developers write)
- `app/` - User's application code
  - `main.ts` - Exports AppModule (user's entry point)
  - `app.module.ts` - Root module definition
  - `modules/` - Feature modules

### Framework Code (Hexane provides)
- `core.ts` - Core APIs (`defineModule`, `createH3AppFromModule`, etc.)
- `routes/[...].ts` - Nitro integration layer (framework-managed)
- `nitro.config.ts` - Nitro configuration

### Documentation
- `USER_GUIDE.md` - How to build apps with Hexane
- `INTEGRATION_COMPARISON.md` - Technical deep-dive on Nitro integration

## Key Questions to Answer

1. **Does module composition work cleanly?**
   - Can modules import other modules?
   - Does dependency tree resolve correctly?

2. **Is it build-tool friendly?**
   - Does Nitro bundle it correctly?
   - Does HMR work?
   - Any issues with circular dependencies?

3. **Is the DX good?**
   - Clear what's happening?
   - Easy to add new modules?
   - TypeScript support solid?

4. **How do routes get registered?**
   - Collect routes from all modules?
   - Maintain route isolation per module?

5. **What about providers/services?**
   - How do services get shared across modules?
   - Scoping (module-level vs app-level)?

## Testing the POC

### Type Checking

```bash
npx tsc --noEmit poc/module-tree/example-app/main.ts
```

### Run with Node (simple)

```bash
node --loader tsx poc/module-tree/example-app/main.ts
```

### Build with Nitro (future)

```bash
cd poc/module-tree
nitro build
```

## Next Steps

After validating this POC:

1. Document findings in this README
2. Create ADR if pattern is solid
3. Discuss provider/DI scope
4. Plan route registration strategy
5. Design module lifecycle hooks (if needed)

## Status

- [x] Basic implementation
- [x] Example app created
- [x] Type checking passes
- [x] Routes work
- [x] Module imports work
- [x] Nitro integration complete
- [x] Multiple deployment targets verified
- [x] Findings documented

## Nitro Integration Results

### ‚úÖ Successfully Implemented

The module tree pattern successfully integrates with Nitro's build system:

1. **Architecture**:
   - `core.ts` exports `createH3AppFromModule()` to build h3 app from module tree
   - `routes/[...].ts` uses catch-all pattern to delegate all requests to our h3 app
   - Nitro automatically detects and bundles the module tree

2. **Developer Experience**:
   ```bash
   npm run dev          # Nitro dev server with HMR
   npm run build        # Production build
   npm run preview      # Preview production build
   ```

3. **Deployment Targets Verified**:
   - ‚úÖ Node.js Server (default)
   - ‚úÖ Cloudflare Pages
   - ‚úÖ Vercel
   - Note: All deployment targets build successfully

4. **Key Benefits**:
   - Module tree composition works seamlessly
   - Routes are collected and registered automatically
   - Zero configuration for basic usage
   - Full type safety maintained
   - Compatible with all Nitro deployment targets

### Abstraction Comparison: Hexane vs Nuxt

Both frameworks elegantly abstract Nitro, but serve different purposes:

| Aspect | Nuxt | Hexane |
|--------|------|--------|
| **Routing** | File-based (`server/api/`) | Module-based (programmatic) |
| **Purpose** | Full-stack framework | Backend API framework |
| **Entry Point** | Multiple files auto-scanned | Single module tree |
| **Developer Control** | Convention over configuration | Explicit composition |
| **Use Case** | Web applications | Enterprise APIs |

### Key Learnings

1. **Catch-all Route Pattern**: Using `routes/[...].ts` allows our h3 app to handle all routing internally while Nitro handles the build/deployment
2. **Module Tree at Build Time**: The module tree is traversed once at startup, all routes are registered, then Nitro serves them
3. **Zero Magic**: Unlike file-based routing, developers explicitly compose modules - more verbose but clearer
4. **Type Safety**: Full TypeScript inference works across the entire stack
5. **Edge Compatible**: The abstraction works with edge runtimes (Cloudflare Workers, etc.)

### Plugin vs Catch-All Route

We explored using Nitro plugins for integration but found the catch-all route pattern is the correct approach. See [INTEGRATION_COMPARISON.md](./INTEGRATION_COMPARISON.md) for detailed analysis.

**TL;DR:**
- ‚úÖ **Catch-all route** (`routes/[...].ts`) - Works perfectly, proper lifecycle timing
- ‚ùå **Nitro plugin** - Conceptually cleaner but doesn't work due to timing issues
- üìö **Industry standard** - tRPC, SvelteKit, and others use the same pattern
